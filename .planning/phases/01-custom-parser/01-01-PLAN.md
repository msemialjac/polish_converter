---
phase: 01-custom-parser
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified: [main.py, tests/test_parser.py]
autonomous: true
---

<objective>
Replace `ast.literal_eval()` with a custom tokenizer/parser that treats variable references (`user.id`, `company_ids`) as string tokens rather than attempting to evaluate them.

Purpose: Enable parsing of Odoo domains containing dynamic references that `ast.literal_eval()` cannot handle.
Output: Working parser that handles all valid Odoo 18 domain syntax including dynamic references.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
@~/.claude/get-shit-done/references/tdd.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@main.py

**Phase 1 Requirements:**
- PARSE-01: Parser handles domains containing dynamic references (`user.id`, `user.partner_id.id`, `company_ids`)
- PARSE-02: Parser handles domains containing dotted field paths (`account_online_link_id.company_id`)
- PARSE-03: Parser handles multi-line domain strings gracefully

**Current Implementation Problem:**
Line 235 in main.py uses `ast.literal_eval(domain_str)` which only handles Python literals.
Variable references like `user.id` or `company_ids` cause `SyntaxError` or `ValueError`.

**Solution Approach:**
Create a custom tokenizer that recognizes:
- Strings (single/double quoted)
- Numbers (integers, floats)
- Booleans (True, False)
- None
- Lists (with nested elements)
- Tuples (with nested elements)
- Identifiers/variable references (treated as DynamicRef objects or strings)
- Operators (&, |, !)

The parser produces the same data structure as `ast.literal_eval()` would, but preserves variable references as special tokens (either as strings or a DynamicRef wrapper class).
</context>

<feature>
  <name>Custom Domain Parser</name>
  <files>main.py, tests/test_parser.py</files>
  <behavior>
    parse_domain(string) -> list structure identical to ast.literal_eval() for valid Python literals, but also handles:

    **Test cases (input -> expected output):**

    1. Standard domain (baseline - should match ast.literal_eval):
       `"[('field', '=', 'value')]"` -> `[('field', '=', 'value')]`

    2. Dynamic reference in value position:
       `"[('user_id', '=', user.id)]"` -> `[('user_id', '=', DynamicRef('user.id'))]`

    3. Dotted path in value:
       `"[('partner_id', '=', user.partner_id.id)]"` -> `[('partner_id', '=', DynamicRef('user.partner_id.id'))]`

    4. Variable reference (no dots):
       `"[('company_id', 'in', company_ids)]"` -> `[('company_id', 'in', DynamicRef('company_ids'))]`

    5. Complex domain with operators:
       `"['|', ('user_id', '=', user.id), ('company_id', 'in', company_ids)]"` ->
       `['|', ('user_id', '=', DynamicRef('user.id')), ('company_id', 'in', DynamicRef('company_ids'))]`

    6. Multi-line string:
       ```
       "[
           ('field', '=', 'value'),
           ('other', '!=', False)
       ]"
       ```
       -> `[('field', '=', 'value'), ('other', '!=', False)]`

    7. Nested list values:
       `"[('state', 'in', ['draft', 'sent'])]"` -> `[('state', 'in', ['draft', 'sent'])]`

    8. Boolean and None values:
       `"[('active', '=', True), ('parent_id', '=', False), ('field', '=', None)]"` ->
       `[('active', '=', True), ('parent_id', '=', False), ('field', '=', None)]`

    9. Numeric values:
       `"[('amount', '>', 100), ('rate', '<', 0.5)]"` -> `[('amount', '>', 100), ('rate', '<', 0.5)]`

    10. Empty domain:
        `"[]"` -> `[]`

    **DynamicRef class:**
    A simple wrapper to distinguish parsed variable references from regular strings:
    ```python
    class DynamicRef:
        def __init__(self, name: str):
            self.name = name
        def __repr__(self):
            return self.name
        def __str__(self):
            return self.name
        def __eq__(self, other):
            return isinstance(other, DynamicRef) and self.name == other.name
    ```
  </behavior>
  <implementation>
    1. Create DynamicRef class for variable references
    2. Create tokenizer function that yields tokens:
       - STRING: 'value' or "value"
       - NUMBER: 123, 45.67, -5
       - BOOL: True, False
       - NONE: None
       - IDENTIFIER: user.id, company_ids (anything that's not a keyword/literal)
       - LPAREN, RPAREN, LBRACKET, RBRACKET, COMMA
       - OPERATOR: '&', '|', '!'
    3. Create recursive descent parser:
       - parse_list() for [...]
       - parse_tuple() for (...)
       - parse_value() for individual values
    4. Replace ast.literal_eval() call in GUI with parse_domain()
    5. Update convert functions to handle DynamicRef (str() gives the name)
  </implementation>
</feature>

<verification>
```bash
# Run tests
python -m pytest tests/test_parser.py -v

# Manual verification with problematic domains
python -c "
from main import parse_domain
print(parse_domain(\"[('user_id', '=', user.id)]\"))
print(parse_domain(\"[('company_id', 'in', company_ids)]\"))
print(parse_domain(\"['|', ('a', '=', 1), ('b', '=', user.partner_id.id)]\"))
"
```
</verification>

<success_criteria>
- DynamicRef class created and handles variable references
- parse_domain() function tokenizes and parses domain strings
- All 10 test cases pass
- GUI uses new parser instead of ast.literal_eval()
- Existing functionality preserved (standard domains still work)
- Multi-line domains parse correctly
- RED-GREEN-REFACTOR cycle completed with atomic commits
</success_criteria>

<output>
After completion, create `.planning/phases/01-custom-parser/01-01-SUMMARY.md` with:
- RED: What tests were written, why they failed
- GREEN: What implementation made them pass
- REFACTOR: What cleanup was done
- Commits: List of commits produced
- Requirements satisfied: PARSE-01, PARSE-02, PARSE-03
</output>
