---
phase: 05-odoo-validation
plan: 03
type: execute
wave: 2
depends_on: ["05-01"]
files_modified: [main.py]
autonomous: true
---

<objective>
Implement operator compatibility and value type validation for Odoo domains.

Purpose: Warn users when operators don't match field types (e.g., 'in' on char field) or when value types are incompatible with field types.
Output: validate_operator() and validate_value_type() functions integrated with domain validation.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-odoo-validation/05-01-SUMMARY.md
@main.py

**Phase 5 Requirements (this plan):**
- VALID-04: Validate operator compatibility for field type
- VALID-06: Warn if value type doesn't match field type

**Odoo field types and compatible operators:**

| Field Type | Compatible Operators |
|------------|---------------------|
| char, text | =, !=, like, ilike, =like, =ilike, in, not in |
| integer, float, monetary | =, !=, >, <, >=, <=, in, not in |
| boolean | =, != |
| date, datetime | =, !=, >, <, >=, <= |
| many2one | =, !=, in, not in, child_of, parent_of |
| one2many, many2many | in, not in, child_of, parent_of |
| selection | =, !=, in, not in |

**Value type expectations:**

| Field Type | Expected Python Types |
|------------|----------------------|
| char, text | str |
| integer | int |
| float, monetary | int, float |
| boolean | bool |
| date | str (YYYY-MM-DD format) |
| datetime | str (YYYY-MM-DD HH:MM:SS format) |
| many2one | int (ID) or False |
| one2many, many2many | list of int (IDs) |
| selection | str (selection key) |
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add operator and type validation to OdooConnection</name>
  <files>main.py</files>
  <action>
    Extend OdooConnection class:

    1. Create FIELD_TYPE_OPERATORS constant dict mapping field types to allowed operators:
       ```python
       FIELD_TYPE_OPERATORS = {
           'char': {'=', '!=', 'like', 'ilike', '=like', '=ilike', 'in', 'not in'},
           'text': {'=', '!=', 'like', 'ilike', '=like', '=ilike', 'in', 'not in'},
           'integer': {'=', '!=', '>', '<', '>=', '<=', 'in', 'not in'},
           'float': {'=', '!=', '>', '<', '>=', '<=', 'in', 'not in'},
           'monetary': {'=', '!=', '>', '<', '>=', '<=', 'in', 'not in'},
           'boolean': {'=', '!='},
           'date': {'=', '!=', '>', '<', '>=', '<='},
           'datetime': {'=', '!=', '>', '<', '>=', '<='},
           'many2one': {'=', '!=', 'in', 'not in', 'child_of', 'parent_of'},
           'one2many': {'in', 'not in', 'child_of', 'parent_of'},
           'many2many': {'in', 'not in', 'child_of', 'parent_of'},
           'selection': {'=', '!=', 'in', 'not in'},
       }
       ```

    2. Add `validate_operator(field_type, operator)` method:
       - Check if operator is in allowed set for field_type
       - Return (valid: bool, warning: str | None)
       - Warning: "Operator '{op}' may not work correctly with {field_type} fields"

    3. Create FIELD_TYPE_VALUES constant mapping field types to expected Python types:
       ```python
       FIELD_TYPE_VALUES = {
           'char': (str,),
           'text': (str,),
           'integer': (int,),
           'float': (int, float),
           'monetary': (int, float),
           'boolean': (bool,),
           'date': (str,),  # Will validate format separately
           'datetime': (str,),
           'many2one': (int, bool, type(None)),  # ID or False/None
           'one2many': (list,),
           'many2many': (list,),
           'selection': (str,),
       }
       ```

    4. Add `validate_value_type(field_type, value)` method:
       - Check if value type matches expected types for field_type
       - Skip validation for DynamicRef (can't validate at parse time)
       - Return (valid: bool, warning: str | None)
       - Warning: "Value type {type(value)} may not match {field_type} field"

    5. For date/datetime fields, optionally validate format if value is string
  </action>
  <verify>
    python -c "
    from main import OdooConnection

    # Test operator validation
    valid, warn = OdooConnection.validate_operator('char', 'like')
    print(f'char+like: valid={valid}')

    valid, warn = OdooConnection.validate_operator('boolean', '>')
    print(f'boolean+>: valid={valid}, warning={warn}')

    # Test value type validation
    valid, warn = OdooConnection.validate_value_type('integer', 42)
    print(f'integer+42: valid={valid}')

    valid, warn = OdooConnection.validate_value_type('integer', 'abc')
    print(f'integer+\"abc\": valid={valid}, warning={warn}')
    "
  </verify>
  <done>validate_operator and validate_value_type methods work correctly</done>
</task>

<task type="auto">
  <name>Task 2: Integrate type/operator validation with domain validation</name>
  <files>main.py</files>
  <action>
    Extend validation flow:

    1. Create `validate_domain_condition(model_name, condition)` method:
       - Takes a single (field, operator, value) tuple
       - Validates field exists (from 05-02)
       - Validates operator is compatible with field type
       - Validates value type matches field type
       - Returns list of (level: str, message: str) warnings
       - level can be "error", "warning", "info"

    2. Create `validate_domain(model_name, domain)` method:
       - Parse domain (if string) or use as-is (if list)
       - For each condition tuple, call validate_domain_condition
       - Collect all warnings
       - Return list of all (level, message) tuples

    3. Update GUI validation to use new comprehensive validation:
       - Call validate_domain with model and parsed domain
       - Display all warnings grouped by level
       - Error messages in red, warnings in yellow/orange

    4. Make validation async-friendly (don't block GUI):
       - Keep validation quick by using cached field info
       - Show "Validating..." while in progress if needed
  </action>
  <verify>
    python -c "
    from main import OdooConnection, parse_domain

    conn = OdooConnection('http://localhost:8069', 'your_db', 'admin', 'admin')
    conn.authenticate()

    # Test comprehensive validation
    domain = parse_domain(\"[('name', '>', 1), ('active', 'like', 'test')]\")
    warnings = conn.validate_domain('res.partner', domain)
    for level, msg in warnings:
        print(f'{level}: {msg}')
    "
  </verify>
  <done>validate_domain returns comprehensive validation results, GUI shows type/operator warnings</done>
</task>

</tasks>

<verification>
```bash
# Run all tests
python -m pytest tests/ -v --tb=short

# Comprehensive validation test
python -c "
from main import OdooConnection, parse_domain

conn = OdooConnection('http://localhost:8069', 'your_db', 'admin', 'admin')
if conn.authenticate():
    # Test various validation scenarios
    test_cases = [
        (\"[('name', '=', 'Test')]\", 'Valid char with ='),
        (\"[('name', '>', 5)]\", 'Char field with > operator'),
        (\"[('active', 'like', 'x')]\", 'Boolean with like'),
        (\"[('company_id', '=', 'string')]\", 'Many2one with string value'),
    ]

    for domain_str, desc in test_cases:
        domain = parse_domain(domain_str)
        warnings = conn.validate_domain('res.partner', domain)
        print(f'{desc}:')
        for level, msg in warnings:
            print(f'  {level}: {msg}')
        print()
"
```
</verification>

<success_criteria>
- FIELD_TYPE_OPERATORS defines compatible operators per type
- FIELD_TYPE_VALUES defines expected Python types per field type
- validate_operator() detects incompatible operator/type combinations
- validate_value_type() detects mismatched value types
- validate_domain() provides comprehensive domain validation
- GUI displays all validation warnings with appropriate styling
- All existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/05-odoo-validation/05-03-SUMMARY.md` with:
- Type/operator validation implementation details
- Integration with domain validation
- Any edge cases encountered
- Commits produced
- Requirements satisfied: VALID-04, VALID-06
</output>
